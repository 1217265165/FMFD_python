你现在作为一个“论文工程实现 + Python 架构优化”的智能助手，帮我把一篇小论文对应的故障诊断方法完整落地到代码里，并对现有代码进行优化重构。

【一、研究与工程背景】

1. 我的大论文整体方向：频谱分析仪故障诊断，采用“知识驱动 + BRB + 分层推理 + 规则压缩”的思路，利用频率响应数据做故障定位。
2. 小论文题目（核心要实现的那篇）：《基于知识驱动规则优化与分层推理的频谱分析仪故障诊断方法》。
3. 我已经有一些设计文档和说明（不用你去找文件，只要遵守下面抽取出来的思想）：
   - 整体流程：先构建 RRS 基准 + 动态包络 → 提取系统级特征 → 系统级 BRB 推理 → 激活模块层 BRB → 输出 21 模块故障概率。
   - BRB.md：说明标准 BRB/ER 推理过程与参数含义。
   - ACCURACY_IMPROVEMENT.md：说明了特征归一化、正常状态识别、softmax 温度、阈值策略等精度优化点。

4. 对比方法必须是近年来较新的 BRB 类方法（不要再用最老那一批 HCF / 传统 BRB / 纯 ER-c 作为唯一对比），需要在代码和实验中体现以下几类方法：
   - BRB-MU / Trustworthy Fault Diagnosis（多源不确定信息，可信诊断）
   - Deep BRB（DBRB，深层 BRB 网络结构，解决组合爆炸）
   - AIFD（Adaptive Interpretable BRB，小样本 + 解释性）
   - A-IBRB（自动化 Interval-BRB，自动结构构建，弱化专家依赖）
   - BRB-P（BRB + Probability Table + Interpretability Constraints）

不要求你完全复现论文细节算法，但需要在代码结构上为上述方法预留接口/子模块，并在 README 和实验章节中写出清晰说明。

--------------------------------------------------
【二、代码整体要求】

1. 整体项目结构（可以调整优化，但请保持大致分层思想）：

   project/
    ├── baseline/                # RRS 构建 + 包络提取
    ├── features/                # 系统级 & 模块级特征提取
    ├── BRB/                     # BRB 推理相关（系统层 + 模块层）
    ├── methods/                 # 其他对比方法封装目录
    │     ├── ours/              # 本文提出方法
    │     ├── brb_mu/
    │     ├── dbrb/
    │     ├── aifd/
    │     ├── a_ibrb/
    │     └── brb_p/
    ├── pipelines/               # 实验脚本 & 流水线
    │     ├── run_baseline.py
    │     ├── simulate/
    │     ├── detect.py
    │     └── compare_methods.py
    ├── comparison/              # 结果分析 & 可视化
    ├── data/                    # 输入数据
    └── Output/                  # 运行输出结果

2. 编码规范：
   - 语言：Python 3
   - 风格：模块化、可读性高，函数名/类名用英文，注释可以用简洁中文（可注明对应的论文公式/章节）。
   - 核心模块必须写清晰 docstring，并标明对应“小论文章节和公式编号”，例如：
     - `baseline/baseline.py`：对应“大论文整体流程中的 RRS 与动态包络构建部分”
     - `BRB/system_brb.py`：对应“小论文系统级 BRB 推理章节”
     - `BRB/module_brb.py`：对应“小论文模块层 BRB 与分层推理章节”
   - 不随意改动理论：实现可以优化，但不能随意改动 BRB 推理公式、特征含义、分层逻辑。

--------------------------------------------------
【三、需要你完成 / 优化的功能模块】

### 1. 特征提取模块优化（features/feature_extraction.py）

目标：实现并对齐小论文中定义的系统级 & 模块级特征，使之能直接支撑后续 BRB 推理和对比方法。

1.1 系统级特征（至少包括）：
  - X1：整体幅度偏移
  - X2：带内平坦度指标
  - X3：高频段衰减斜率
  - X4：频率标度非线性度
  - X5：幅度缩放一致性

要求：
  - 每个特征有清晰 docstring，说明物理含义 + 对应论文公式编号（比如 “对应式 (1-2)”）。
  - 函数接口统一，例如：
    - `extract_system_features(response_curve) -> dict`
    - `extract_module_features(response_curve, module_id) -> dict`
  - 输出的数据结构要方便后面 BRB 和对比方法复用（例如 DataFrame 或统一 dict）。

### 2. 系统级 BRB 推理（BRB/system_brb.py）

目标：实现系统级故障诊断（正常 / 幅度类 / 频率类 / 参考电平类），并支持正常状态识别与不确定度输出。

需要实现：
  - 属性匹配度计算：将 X1~X4 映射到语言值（High / Normal / Low）。
  - 规则激活权重：考虑属性权重 + 规则权重。
  - 基于 ER 的信念合成过程。
  - 正常状态识别逻辑：
    - 对特征进行归一化（阈值根据 ACCURACY_IMPROVEMENT.md 思想来设置）。
    - 引入 overall_score，用于衡量整体异常程度。
    - 使用 softmax 温度参数 alpha（例如 2.0）抑制过度自信。
    - 设定 max_prob < 某个阈值（如 0.3）时，输出“正常”状态，并显式给出不确定度。

接口建议：
  - `system_level_infer(features: dict) -> dict`
    - 返回：系统级故障类别（或概率分布）、最大概率、是否判断为正常、不确定性等。

### 3. 模块层 BRB 推理与规则压缩（BRB/module_brb.py）

目标：对 21 个模块进行诊断，实现知识驱动的规则压缩与分层推理。

要求：
  - 支持 21 个模块（可以通过配置文件/枚举定义模块列表）。
  - 使用系统级诊断结果作为“虚拟先验属性 V”，控制哪些模块需要激活推理。
  - 针对不同系统级故障类别，模块层使用对应的特征子集（例如幅度类、频率类、参考电平类各用不同特征组合）。
  - 仅保留物理链路上可能相关的规则组合，显式体现“规则压缩”的思想：
    - 目标数量级：规则数约 45，参数数约 38（不是硬性，但要明显少于传统全组合 BRB）。
  - 输出：
    - 21 维模块故障概率向量
    - 对应的不确定度（可选）

接口建议：
  - `module_level_infer(features: dict, system_result: dict) -> dict`

### 4. Pipeline 串联与对比实验（pipelines/）

目标：从“数据 → baseline 构建 → 特征提取 → 本文方法 + 5 种对比方法 → 统一评估与可视化”的一键流程。

必须实现以下脚本（可以已有基础上进行重构）：

4.1 `run_baseline.py`
  - 输入：正常频响数据（例如 data/normal/*.csv）
  - 输出：baseline 构件与统计量，比如：
    - `Output/baseline_artifacts.npz`
    - `Output/baseline_meta.json`
    - `Output/normal_feature_stats.csv`

4.2 `simulate/run_simulation_brb.py`
  - 用 baseline 生成仿真故障数据（多类故障，包括系统级和模块级）。
  - 自动跑：
    - 特征提取
    - 系统 + 模块两层 BRB 推理
  - 输出：
    - 特征数据集
    - 诊断结果（含标签）

4.3 `detect.py`
  - 输入：真实或仿真待测频响数据（to_detect/*.csv）
  - 输出：每条数据的
    - 系统级诊断类别 + 概率
    - 模块级 21 维故障概率
    - 是否告警（warn / alarm / normal）

4.4 `compare_methods.py`（重点）
  - 统一对比本文方法和 5 个对比方法：
    - ours（知识驱动规则压缩 + 分层 BRB）
    - brb_mu
    - dbrb
    - aifd
    - a_ibrb
    - brb_p
  - 强制采用统一接口，例如为每个方法提供一个 `run_method(features)`：
    - 输入：特征（系统级 + 模块级）
    - 输出：系统级预测 + 模块级概率 + 不确定度（尽可能统一格式）
  - 指标计算：
    - 系统级：Accuracy、Macro-F1、混淆矩阵
    - 模块级：Top-1/Top-3 准确率
    - 模型复杂度：规则数量 + 参数数量（可在方法配置中给出）
    - 推理效率：单样本平均推理时间
  - 输出文件（放在 Output/ 下）：
    - `comparison_table.csv`（方法 vs 各指标）
    - `performance_table.csv`（详细结果）
    - `confusion_system.png`（系统级混淆矩阵）
    - `confusion_module.png`（模块级混淆矩阵）

你可以为 5 个对比方法写“简化版实现”：
  - 行为上尽量贴近相应论文思想（例如：BRB-MU 多考虑不确定因子、DBRB 表现为分层结构、A-IBRB 使用区间参考值等），
  - 但具体公式可以做适当抽象，只要在 README / 注释里写明是“按文献思想改写的工程实现”。

--------------------------------------------------
【四、文档与论文文本部分（需要你顺手生成草稿）】

1. README 优化：
   - 清晰介绍：本文方法整体流程、代码结构、每个模块作用。
   - 明确列出：6 种方法（本文 + 5 对比），并简要说明各自特点。
   - 给出：如何一键复现实验的命令示例。

2. 论文《Related Work》与《Contribution》草稿：
   - Related Work：按这几类方法写一节综述：
     - BRB-MU（多源不确定性 + 可信性）
     - DBRB（深层 BRB + 组合爆炸问题）
     - AIFD（自适应 + 可解释性）
     - A-IBRB（自动化 interval-BRB）
     - BRB-P（概率表 + 解释性约束）
   - Contribution：强调本文在“知识驱动规则压缩 + 分层 BRB + 频谱分析仪这一具体对象上的工程实现与效果提升”。

3. 论文《实验设计》章节草稿：
   - 包括：实验目的、数据集与划分方式、评价指标、对比方法列表、实验流程图/描述。
   - 文字风格偏 SCI / EI 论文风格，逻辑清晰，段落结构规范。

--------------------------------------------------
【五、使用方式】

当我让你“写某个模块代码 / 重构某个文件 / 生成实验章节文本 / 优化 README”时：
  - 先按上面整体设计理解我的需求；
  - 保证不违背大论文和小论文的理论设定；
  - 代码要能直接放进相应目录运行（包括必要的导入和伪数据示例）；
  - 文本要能直接粘到论文或 README 里用。

现在请基于上述要求，开始从最关键的部分着手（可以优先给出 compare_methods.py 的骨架 + README 对比方法部分 + 系统级 BRB 接口设计），后续我会根据需要让你逐个细化模块或直接要完整代码。
